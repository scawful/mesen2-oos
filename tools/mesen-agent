#!/usr/bin/env python3
import argparse
import sys
import os
import subprocess
import shutil
import glob
from pathlib import Path

# Configuration
MESEN_RUN_CMD = "mesen-run" # Assumed to be in PATH or linked
SKILLS_DIR = os.path.expanduser("~/src/hobby/mesen2-oos/docs/skills")

def _default_instances_dir():
    override = os.environ.get("MESEN2_INSTANCES_DIR")
    if override:
        return os.path.expanduser(override)
    if sys.platform == "darwin":
        return os.path.expanduser("~/Library/Application Support/Mesen2-instances")
    if os.name == "nt":
        base = os.environ.get("APPDATA", os.path.expanduser("~"))
        return os.path.join(base, "Mesen2-instances")
    return os.path.expanduser("~/.config/Mesen2-instances")

# Default location for instances created by mesen-run (override with MESEN2_INSTANCES_DIR)
INSTANCES_DIR = _default_instances_dir()

def get_instance_path(name):
    return os.path.join(INSTANCES_DIR, name)

def get_running_sessions():
    """Returns a list of dictionaries with info about running Mesen processes."""
    sessions = []
    try:
        tmp_path = Path("/tmp")
        for p in tmp_path.glob("mesen2-*.sock"):
            try:
                # Format: mesen2-<PID>.sock
                pid = p.stem.split("-")[1]
                # Check if process is still running
                try:
                    os.kill(int(pid), 0)
                except OSError:
                    continue # Stale socket
                
                sessions.append({
                   "pid": pid,
                   "socket": str(p),
                   "name": "unknown" 
                })
            except (ValueError, IndexError):
                continue
    except Exception as e:
        print(f"Error listing sessions: {e}", file=sys.stderr)
    return sessions

def cmd_session_list(args):
    print("Active Mesen2 Sessions (Socket Check):")
    sessions = get_running_sessions()
    if not sessions:
        print("  No active sessions found.")
    for s in sessions:
        print(f"  PID: {s['pid']} | Socket: {s['socket']}")
    
    print("\nKnown Instance Directories:")
    if os.path.isdir(INSTANCES_DIR):
        for name in os.listdir(INSTANCES_DIR):
            path = os.path.join(INSTANCES_DIR, name)
            if os.path.isdir(path):
                print(f"  Name: {name}")
                print(f"    Path: {path}")
    else:
        print(f"  {INSTANCES_DIR} does not exist.")

def cmd_session_start(args):
    name = args.name
    print(f"Starting session '{name}'...")
    # We call mesen-run directly
    cmd = [MESEN_RUN_CMD, f"--name={name}"]
    if args.headless:
        cmd.append("--headless")
    
    # Launch detached
    # Use Popen to launch in background
    try:
        subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
        print(f"Session '{name}' launched in background.")
    except FileNotFoundError:
        print(f"Error: '{MESEN_RUN_CMD}' not found in PATH.")

def cmd_session_stop(args):
    print(f"To stop session '{args.name}', find its PID via 'session list' and use 'kill <PID>'")

def cmd_share_config(args):
    src = get_instance_path(args.src)
    dest = get_instance_path(args.dest)
    
    if not os.path.exists(src):
        print(f"Source instance '{args.src}' not found at {src}")
        return
    
    if not os.path.exists(dest):
        print(f"Destination instance '{args.dest}' does not exist. Creating...")
        os.makedirs(dest, exist_ok=True)

    # Files to copy
    files = ["settings.xml", "input.xml"]
    for f in files:
        s_file = os.path.join(src, f)
        d_file = os.path.join(dest, f)
        if os.path.exists(s_file):
            shutil.copy2(s_file, d_file)
            print(f"Copied {f} from {args.src} to {args.dest}")
        else:
            print(f"Warning: {f} not found in {args.src}")

def cmd_share_state(args):
    src = get_instance_path(args.src)
    dest = get_instance_path(args.dest)
    
    src_saves = os.path.join(src, "Mesen2", "SaveStates")
    # If not there, try root
    if not os.path.exists(src_saves):
         src_saves = os.path.join(src, "SaveStates")
         
    dest_saves = os.path.join(dest, "SaveStates") # Normalize to root for destination if simple
    
    if os.path.exists(src_saves):
        # We need to copy contents
        if not os.path.exists(dest_saves):
             os.makedirs(dest_saves)

        # Copy all files
        for item in os.listdir(src_saves):
            s = os.path.join(src_saves, item)
            d = os.path.join(dest_saves, item)
            if os.path.isfile(s):
                shutil.copy2(s, d)
                print(f"Copied {item}")
            elif os.path.isdir(s):
                # Recursive copy
                shutil.copytree(s, d, dirs_exist_ok=True)
                print(f"Copied directory {item}")
    else:
         print(f"No SaveStates directory found in {src}")

def cmd_skill_list(args):
    if not os.path.isdir(SKILLS_DIR):
        print(f"Skills directory not found: {SKILLS_DIR}")
        return
    
    print("Available Skills:")
    for f in sorted(os.listdir(SKILLS_DIR)):
        if f.endswith(".md"):
            print(f"  {f[:-3]}")

def cmd_skill_read(args):
    path = os.path.join(SKILLS_DIR, f"{args.name}.md")
    if not os.path.exists(path):
        print(f"Skill '{args.name}' not found.")
        return
    
    with open(path, 'r') as f:
        print(f.read())

def main():
    parser = argparse.ArgumentParser(description="Mesen Agentic Interface")
    subparsers = parser.add_subparsers(dest="command")
    
    # Session
    p_session = subparsers.add_parser("session", help="Manage sessions")
    sp_session = p_session.add_subparsers(dest="subcommand")
    
    sp_sess_list = sp_session.add_parser("list", help="List sessions")
    sp_sess_list.set_defaults(func=cmd_session_list)
    
    sp_sess_start = sp_session.add_parser("start", help="Start session")
    sp_sess_start.add_argument("name", help="Session name")
    sp_sess_start.add_argument("--headless", action="store_true", help="Start headless")
    sp_sess_start.set_defaults(func=cmd_session_start)
    
    sp_sess_stop = sp_session.add_parser("stop", help="Stop session")
    sp_sess_stop.add_argument("name", help="Session name")
    sp_sess_stop.set_defaults(func=cmd_session_stop)
    
    # Share
    p_share = subparsers.add_parser("share", help="Share resources")
    sp_share = p_share.add_subparsers(dest="subcommand")
    
    sp_share_cfg = sp_share.add_parser("config", help="Share config")
    sp_share_cfg.add_argument("src", help="Source instance name")
    sp_share_cfg.add_argument("dest", help="Destination instance name")
    sp_share_cfg.set_defaults(func=cmd_share_config)
    
    sp_share_state = sp_share.add_parser("state", help="Share save states")
    sp_share_state.add_argument("src", help="Source instance name")
    sp_share_state.add_argument("dest", help="Destination instance name")
    sp_share_state.set_defaults(func=cmd_share_state)
    
    # Skill
    p_skill = subparsers.add_parser("skill", help="Documentation/Skills")
    sp_skill = p_skill.add_subparsers(dest="subcommand")
    
    sp_skill_list = sp_skill.add_parser("list", help="List skills")
    sp_skill_list.set_defaults(func=cmd_skill_list)
    
    sp_skill_read = sp_skill.add_parser("read", help="Read skill")
    sp_skill_read.add_argument("name", help="Skill name")
    sp_skill_read.set_defaults(func=cmd_skill_read)
    
    args = parser.parse_args()
    if hasattr(args, 'func'):
        args.func(args)
    else:
        parser.print_help()

if __name__ == "__main__":
    main()
